{
  "version": 3,
  "sources": ["../node_modules/.pnpm/@simplyhexagonal+function-queue@2.0.0/node_modules/@simplyhexagonal/function-queue/node_modules/.pnpm/short-unique-id@4.4.4/node_modules/short-unique-id/src/index.ts", "../node_modules/.pnpm/@simplyhexagonal+function-queue@2.0.0/node_modules/@simplyhexagonal/function-queue/src/index.ts", "../src/index.ts"],
  "sourcesContent": ["// @module ShortUniqueId\n\n// Copyright 2017-2021 the Short Unique ID authors. All rights reserved. Apache 2.0 license.\n\n// @ts-ignore\nimport {version} from '../package.json';\n\ninterface ShortUniqueIdRanges {\n  [k: string]: [number, number];\n};\n\ntype defaultDictionaries = 'number' | 'alpha' | 'alpha_lower' | 'alpha_upper' | 'alphanum' | 'alphanum_lower' | 'alphanum_upper' | 'hex';\n\n/**\n * ```js\n * {\n *   dictionary: ['z', 'a', 'p', 'h', 'o', 'd', ...],\n *   shuffle: false,\n *   debug: false,\n *   length: 6,\n * }\n * ```\n */\nexport interface ShortUniqueIdOptions {\n  /** User-defined character dictionary */\n  dictionary: string[] | defaultDictionaries;\n\n  /** If true, sequentialUUID use the dictionary in the given order */\n  shuffle: boolean;\n\n  /** If true the instance will console.log useful info */\n  debug: boolean;\n\n  /** From 1 to infinity, the length you wish your UUID to be */\n  length: number;\n};\n\n/**\n * 6 was chosen as the default UUID length since for most cases\n * it will be more than aptly suitable to provide millions of UUIDs\n * with a very low probability of producing a duplicate UUID.\n *\n * For example, with a dictionary including digits from 0 to 9,\n * as well as the alphabet from a to z both in UPPER and lower case,\n * the probability of generating a duplicate in 1,000,000 rounds\n * is ~0.00000002, or about 1 in 50,000,000.\n */\nexport const DEFAULT_UUID_LENGTH: number = 6;\n\nconst DEFAULT_OPTIONS: ShortUniqueIdOptions = {\n  dictionary: 'alphanum',\n  shuffle: true,\n  debug: false,\n  length: DEFAULT_UUID_LENGTH,\n};\n\n/**\n * Generate random or sequential UUID of any length.\n *\n * ### Use as module\n *\n * ```js\n * // Deno (web module) Import\n * import ShortUniqueId from 'https://cdn.jsdelivr.net/npm/short-unique-id@latest/src/index.ts';\n *\n * // ES6 / TypeScript Import\n * import ShortUniqueId from 'short-unique-id';\n *\n * //or Node.js require\n * const ShortUniqueId = require('short-unique-id');\n *\n * //Instantiate\n * const uid = new ShortUniqueId();\n *\n * // Random UUID\n * console.log(uid());\n *\n * // Sequential UUID\n * console.log(uid.seq());\n * ```\n *\n * ### Use in browser\n *\n * ```html\n * <!-- Import -->\n * <script src=\"https://cdn.jsdelivr.net/npm/short-unique-id@latest/dist/short-unique-id.min.js\"></script>\n *\n * <!-- Usage -->\n * <script>\n *   // Instantiate\n *   var uid = new ShortUniqueId();\n *\n *   // Random UUID\n *   document.write(uid());\n *\n *   // Sequential UUID\n *   document.write(uid.seq());\n * </script>\n * ```\n *\n * ### Options\n *\n * Options can be passed when instantiating `uid`:\n *\n * ```js\n * const options = { ... };\n *\n * const uid = new ShortUniqueId(options);\n * ```\n *\n * For more information take a look at the [ShortUniqueIdOptions type definition](/interfaces/shortuniqueidoptions.html).\n */\nexport default class ShortUniqueId extends Function {\n  static default: typeof ShortUniqueId = ShortUniqueId;\n\n  public counter: number;\n  public debug: boolean;\n  public dict: string[];\n  public version: string;\n  public dictIndex: number = 0;\n  public dictRange: number[] =[];\n  public lowerBound: number = 0;\n  public upperBound: number = 0;\n  public dictLength: number = 0;\n  public uuidLength: number;\n\n  protected _digit_first_ascii: number = 48;\n  protected _digit_last_ascii: number = 58;\n  protected _alpha_lower_first_ascii: number = 97;\n  protected _alpha_lower_last_ascii: number = 123;\n  protected _hex_last_ascii: number = 103;\n  protected _alpha_upper_first_ascii: number = 65;\n  protected _alpha_upper_last_ascii: number = 91;\n\n  protected _number_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n  };\n\n  protected _alpha_dict_ranges: ShortUniqueIdRanges = {\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _alpha_lower_dict_ranges: ShortUniqueIdRanges = {\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n  };\n\n  protected _alpha_upper_dict_ranges: ShortUniqueIdRanges = {\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _alphanum_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _alphanum_lower_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n  };\n\n  protected _alphanum_upper_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _hex_dict_ranges: ShortUniqueIdRanges = {\n    decDigits: [this._digit_first_ascii, this._digit_last_ascii],\n    alphaDigits: [this._alpha_lower_first_ascii, this._hex_last_ascii],\n  };\n\n  /* tslint:disable consistent-return */\n  protected log = (...args: any[]): void => {\n    const finalArgs = [...args];\n    finalArgs[0] = `[short-unique-id] ${args[0]}`;\n    /* tslint:disable no-console */\n    if (this.debug === true) {\n      if (typeof console !== 'undefined' && console !== null) {\n        return console.log(...finalArgs);\n      }\n    }\n    /* tslint:enable no-console */\n  };\n  /* tslint:enable consistent-return */\n\n  /** Change the dictionary after initialization. */\n  setDictionary = (dictionary: string[] | defaultDictionaries, shuffle?: boolean): void => {\n    let finalDict: string[];\n\n    if (dictionary && Array.isArray(dictionary) && dictionary.length > 1) {\n      finalDict = dictionary as string[];\n    } else {\n      finalDict = [];\n\n      let i;\n\n      this.dictIndex = i = 0;\n\n      const rangesName = `_${dictionary as defaultDictionaries}_dict_ranges`;\n      const ranges: ShortUniqueIdRanges = this[rangesName as keyof ShortUniqueId];\n\n      Object.keys(ranges).forEach((rangeType) => {\n        const rangeTypeKey = rangeType;\n\n        this.dictRange = ranges[rangeTypeKey];\n\n        this.lowerBound = this.dictRange[0];\n        this.upperBound = this.dictRange[1];\n\n        for (\n          this.dictIndex = i = this.lowerBound;\n          this.lowerBound <= this.upperBound ? i < this.upperBound : i > this.upperBound;\n          this.dictIndex = this.lowerBound <= this.upperBound ? i += 1 : i -= 1\n        ) {\n          finalDict.push(String.fromCharCode(this.dictIndex));\n        }\n      });\n    }\n\n    if (shuffle) {\n      // Shuffle Dictionary to remove selection bias.\n      const PROBABILITY = 0.5;\n      finalDict = finalDict.sort(() => Math.random() - PROBABILITY);\n    }\n\n    this.dict = finalDict;\n\n    // Cache Dictionary Length for future usage.\n    this.dictLength = this.dict.length;// Resets internal counter.\n    this.counter = 0;\n  };\n\n  seq = (): string => {\n    return this.sequentialUUID();\n  };\n\n  /**\n   * Generates UUID based on internal counter that's incremented after each ID generation.\n   * @alias `const uid = new ShortUniqueId(); uid.seq();`\n   */\n  sequentialUUID = (): string => {\n    let counterDiv: number;\n    let counterRem: number;\n    let id: string = '';\n\n    counterDiv = this.counter;\n\n    do {\n      counterRem = counterDiv % this.dictLength;\n      counterDiv = Math.trunc(counterDiv / this.dictLength);\n      id += this.dict[counterRem];\n    } while (counterDiv !== 0);\n\n    this.counter += 1;\n\n    return id;\n  };\n\n  /**\n   * Generates UUID by creating each part randomly.\n   * @alias `const uid = new ShortUniqueId(); uid(uuidLength: number);`\n   */\n  randomUUID = (uuidLength: number = this.uuidLength || DEFAULT_UUID_LENGTH): string => {\n    let id: string;\n    let randomPartIdx: number;\n    let j: number;\n\n    if ((uuidLength === null || typeof uuidLength === 'undefined') || uuidLength < 1) {\n      throw new Error('Invalid UUID Length Provided');\n    }\n\n    const isPositive = uuidLength >= 0;\n\n    // Generate random ID parts from Dictionary.\n    id = '';\n    for (\n      j = 0;\n      j < uuidLength;\n      j += 1\n    ) {\n      randomPartIdx = parseInt(\n        (Math.random() * this.dictLength).toFixed(0),\n        10,\n      ) % this.dictLength;\n      id += this.dict[randomPartIdx];\n    }\n\n    // Return random generated ID.\n    return id;\n  };\n\n  /**\n   * Calculates total number of possible UUIDs.\n   *\n   * Given that:\n   *\n   * - `H` is the total number of possible UUIDs\n   * - `n` is the number of unique characters in the dictionary\n   * - `l` is the UUID length\n   *\n   * Then `H` is defined as `n` to the power of `l`:\n   *\n   * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20H=n%5El)\n   *\n   * This function returns `H`.\n   */\n  availableUUIDs = (uuidLength: number = this.uuidLength): number => {\n    return parseFloat(\n      Math.pow([...new Set(this.dict)].length, uuidLength).toFixed(0),\n    );\n  };\n\n  /**\n   * Calculates approximate number of hashes before first collision.\n   *\n   * Given that:\n   *\n   * - `H` is the total number of possible UUIDs, or in terms of this library,\n   * the result of running `availableUUIDs()`\n   * - the expected number of values we have to choose before finding the\n   * first collision can be expressed as the quantity `Q(H)`\n   *\n   * Then `Q(H)` can be approximated as the square root of the product of half\n   * of pi times `H`:\n   *\n   * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20Q(H)%5Capprox%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7DH%7D)\n   *\n   * This function returns `Q(H)`.\n   * \n   * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n   */\n  approxMaxBeforeCollision = (rounds: number = this.availableUUIDs(this.uuidLength)): number => {\n    return parseFloat(\n      Math.sqrt((Math.PI / 2) * rounds).toFixed(20),\n    );\n  };\n\n  /**\n   * Calculates probability of generating duplicate UUIDs (a collision) in a\n   * given number of UUID generation rounds.\n   *\n   * Given that:\n   *\n   * - `r` is the maximum number of times that `randomUUID()` will be called,\n   * or better said the number of _rounds_\n   * - `H` is the total number of possible UUIDs, or in terms of this library,\n   * the result of running `availableUUIDs()`\n   *\n   * Then the probability of collision `p(r; H)` can be approximated as the result\n   * of dividing the square root of the product of half of pi times `r` by `H`:\n   *\n   * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20p(r%3B%20H)%5Capprox%5Cfrac%7B%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7Dr%7D%7D%7BH%7D)\n   *\n   * This function returns `p(r; H)`.\n   * \n   * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n   *\n   * (Useful if you are wondering _\"If I use this lib and expect to perform at most\n   * `r` rounds of UUID generations, what is the probability that I will hit a duplicate UUID?\"_.)\n   */\n  collisionProbability = (\n    rounds: number = this.availableUUIDs(this.uuidLength),\n    uuidLength: number = this.uuidLength,\n  ): number => {\n    return parseFloat(\n      (\n        this.approxMaxBeforeCollision(rounds) / this.availableUUIDs(uuidLength)\n      ).toFixed(20),\n    );\n  };\n\n  /**\n   * Calculate a \"uniqueness\" score (from 0 to 1) of UUIDs based on size of\n   * dictionary and chosen UUID length.\n   *\n   * Given that:\n   *\n   * - `H` is the total number of possible UUIDs, or in terms of this library,\n   * the result of running `availableUUIDs()`\n   * - `Q(H)` is the approximate number of hashes before first collision,\n   * or in terms of this library, the result of running `approxMaxBeforeCollision()`\n   *\n   * Then `uniqueness` can be expressed as the additive inverse of the probability of\n   * generating a \"word\" I had previously generated (a duplicate) at any given iteration\n   * up to the the total number of possible UUIDs expressed as the quotiend of `Q(H)` and `H`:\n   *\n   * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%201-%5Cfrac%7BQ(H)%7D%7BH%7D)\n   *\n   * (Useful if you need a value to rate the \"quality\" of the combination of given dictionary\n   * and UUID length. The closer to 1, higher the uniqueness and thus better the quality.)\n   */\n  uniqueness = (rounds: number = this.availableUUIDs(this.uuidLength)): number => {\n    const score = parseFloat(\n      (1 - (\n        this.approxMaxBeforeCollision(rounds) / rounds\n      )).toFixed(20),\n    );\n    return (\n      score > 1\n    ) ? (\n      1\n    ) : (\n      (score < 0) ? 0 : score\n    );\n  };\n\n  /**\n   * Return the version of this module.\n   */\n  getVersion = (): string => {\n    return this.version;\n  };\n\n  /**\n   * Generates a UUID with a timestamp that can be extracted using `uid.parseStamp(stampString);`.\n   * \n   * ```js\n   *  const uidWithTimestamp = uid.stamp(32);\n   *  console.log(uidWithTimestamp);\n   *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n   * \n   *  console.log(uid.parseStamp(uidWithTimestamp));\n   *  // 2021-05-03T06:24:58.000Z\n   *  ```\n   */\n  stamp = (finalLength: number): string => {\n    if (typeof finalLength !== 'number' || finalLength < 10) {\n      throw new Error('Param finalLength must be number greater than 10');\n    }\n\n    const hexStamp = Math.floor(+new Date() / 1000).toString(16);\n\n    const idLength = finalLength - 9;\n\n    const rndIdx = Math.round(Math.random() * ((idLength > 15) ? 15 : idLength));\n\n    const id = this.randomUUID(idLength);\n\n    return `${id.substr(0, rndIdx)}${hexStamp}${id.substr(rndIdx)}${rndIdx.toString(16)}`;\n  };\n\n  /**\n   * Extracts the date embeded in a UUID generated using the `uid.stamp(finalLength);` method.\n   * \n   * ```js\n   *  const uidWithTimestamp = uid.stamp(32);\n   *  console.log(uidWithTimestamp);\n   *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n   * \n   *  console.log(uid.parseStamp(uidWithTimestamp));\n   *  // 2021-05-03T06:24:58.000Z\n   *  ```\n   */\n  parseStamp = (stamp: string): Date => {\n    if (stamp.length < 10) {\n      throw new Error('Stamp length invalid');\n    }\n\n    const rndIdx = parseInt(stamp.substr(stamp.length - 1, 1), 16);\n\n    return new Date(parseInt(stamp.substr(rndIdx, 8), 16) * 1000);\n  };\n\n  constructor(argOptions: Partial<ShortUniqueIdOptions> = {}) {\n    super();\n\n    const options: ShortUniqueIdOptions = {\n      ...DEFAULT_OPTIONS,\n      ...argOptions as Partial<ShortUniqueIdOptions>,\n    };\n\n    this.counter = 0;\n    this.debug = false;\n    this.dict = [];\n    this.version = version;\n\n    const {\n      dictionary,\n      shuffle,\n      length,\n    } = options;\n\n    this.uuidLength = length;\n\n    this.setDictionary(dictionary, shuffle);\n\n    this.debug = options.debug;\n    this.log(this.dict);\n    this.log((`Generator instantiated with Dictionary Size ${this.dictLength}`));\n\n    return new Proxy(this, {\n      apply: (target, that, args) => this.randomUUID(...args),\n    });\n  }\n}\n", "import ShortUniqueId from 'short-unique-id';\n\n// @ts-ignore\nimport { version } from '../package.json';\n\ntype milliseconds = number;\n\nexport type PayloadId = string;\n\nexport type QueueableFunction<O = {[k: string]: any}, R = void> = (options: O) => Promise<R>;\n\nexport type QueueableSyncFunction<O = {[k: string]: any}, R = void> = (options: O) => R;\n\nexport interface FunctionQueueResult<R = void> {\n  id: PayloadId;\n  duration: milliseconds;\n  startTimestamp: number;\n  endTimestamp: number;\n  result?: R;\n  error?: any;\n};\n\nexport interface FunctionQueueOptions {\n  waitTimeBetweenRuns: milliseconds;\n  getResultTimeout: milliseconds;\n  maxRetries: number;\n  cleanupResultsOlderThan: milliseconds;\n}\n\ninterface FunctionQueueEntry<O = {[k: string]: any}, R = void> {\n  id: PayloadId;\n  payload: O;\n  result?: FunctionQueueResult<R>;\n}\n\nconst uid = new ShortUniqueId({length: 8});\n\nconst defaultOptions: FunctionQueueOptions = {\n  waitTimeBetweenRuns: 100,\n  getResultTimeout: 60000,\n  maxRetries: 1,\n  cleanupResultsOlderThan: 60000,\n};\n\nconst sleep = (ms: milliseconds) => new Promise(resolve => setTimeout(resolve, ms));\n\nclass FunctionQueue<O = {[k: string]: any}, R = void> {\n  static version = version;\n\n  private _fn: QueueableFunction<O, R>;\n  private _queue: FunctionQueueEntry<O, R>[] = [];\n  private _options: FunctionQueueOptions;\n  private _processing: Boolean = false;\n\n  public results: FunctionQueueResult<R>[] = [];\n  public processQueuePromise: Promise<FunctionQueueResult<R>[]> = Promise.resolve([]);\n\n  constructor(\n    fn: QueueableFunction<O, R>,\n    options?: Partial<FunctionQueueOptions>,\n  ) {\n    this._fn = fn;\n    this._options = {\n      ...defaultOptions,\n      ...(options || {}),\n    };\n  }\n\n  public queuePayload(payload: O): PayloadId {\n    const id: PayloadId = uid();\n\n    this._queue.push({payload, id});\n\n    return id;\n  }\n\n  private _tryFn = async (id: string, payload: O, startTimestamp: number): Promise<FunctionQueueResult<R>> => {\n    let retries = 0;\n\n    let finalResult: FunctionQueueResult<R> | undefined;\n\n    while ((!finalResult || (finalResult as any).error) && retries <= this._options.maxRetries) {\n      retries++;\n\n      try {\n        await sleep(this._options.waitTimeBetweenRuns);\n\n        const fnResult = await this._fn(payload);\n        const endTimestamp = Date.now();\n        const duration = endTimestamp - startTimestamp;\n\n        finalResult = {\n          id,\n          duration,\n          startTimestamp,\n          endTimestamp,\n          result: fnResult,\n        };\n      } catch (error) {\n        const endTimestamp = Date.now();\n        const duration = endTimestamp - startTimestamp;\n\n        finalResult = {\n          id,\n          duration,\n          startTimestamp,\n          endTimestamp,\n          error,\n        };\n      }\n    }\n\n    return finalResult as FunctionQueueResult<R>;\n  }\n\n  private async _processQueue(): Promise<void> {\n    this._processing = true;\n\n    let entry: FunctionQueueEntry<O, R>;\n\n    const startTimestamp = Date.now();\n\n    while (entry = this._queue.shift() as FunctionQueueEntry<O, R>) {\n      const { payload, id } = entry;\n\n      try {\n        const result = await this._tryFn(id, payload, startTimestamp);\n\n        this.results.push(\n          {\n            ...result,\n          }\n        );\n      } catch (error) {\n        const endTimestamp = Date.now();\n\n        this.results.push(\n          {\n            id,\n            startTimestamp,\n            duration: endTimestamp - startTimestamp,\n            endTimestamp,\n            error,\n          }\n        );\n      }\n    }\n\n    this._processing = false;\n  }\n\n  public cleanupResults(): void {\n    this.results = this.results.filter(\n      (r) => {\n        const age = (Date.now() - r.endTimestamp);\n\n        return age < this._options.cleanupResultsOlderThan;\n      }\n    );\n  }\n\n  public async processQueue(): Promise<void> {\n    if (this._processing) {\n      return;\n    }\n\n    this.cleanupResults();\n\n    this.processQueuePromise = this._processQueue().then(() => this.results);\n  }\n\n  public async getResult(id: string): Promise<FunctionQueueResult<R>> {\n    this.cleanupResults();\n\n    let result = this.results.find((r) => r.id === id);\n\n    const startTimestamp = Date.now();\n\n    while (!result && (Date.now() - startTimestamp) < this._options.getResultTimeout) {\n      await sleep(this._options.waitTimeBetweenRuns);\n      result = this.results.find((r) => r.id === id);\n    }\n\n    if (!result) {\n      const endTimestamp = Date.now();\n\n      return {\n        id,\n        startTimestamp,\n        duration: endTimestamp - startTimestamp,\n        endTimestamp,\n        error: new Error(\n          `Result for id ${id} not found (timeout of ${this._options.getResultTimeout}ms exceeded)`\n        ),\n      };\n    }\n\n    this.results = this.results.filter((r) => r.id !== id);\n\n    return result;\n  }\n}\n\nexport default FunctionQueue;\n", "import { AxiosStatic, AxiosInstance, AxiosRequestConfig } from 'axios';\nimport FunctionQueue, {\n  QueueableFunction,\n} from '@simplyhexagonal/function-queue';\nimport {\n  LoggerTransportOptions,\n  LoggerTransportResult,\n  LoggerTransport,\n} from '@simplyhexagonal/logger';\n\n// @ts-ignore\nimport {version} from '../package.json';\n// @ts-ignore\nexport {version} from '../package.json';\n\nlet axios: AxiosStatic;\n\nif (typeof window !== 'undefined') {\n  axios = (window as any).axios as AxiosStatic;\n} else {\n  axios = require('axios');\n}\n\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nexport class Multipart {\n  boundary = 'loggerTransportDiscord';\n  multipart = '';\n\n  constructor(...data: {\n    name: string;\n    data: string;\n    fileName?: string;\n  }[]) {\n    if (data.length > 0) {\n      data.forEach(({name, data, fileName}) => {\n        this.append(name, data, fileName)\n      });\n    }\n  }\n\n  append(\n      name: string,\n      data: string,\n      fileName?: string,\n  ): void {\n    if (!data) return;\n\n    let contentInfo = `Content-Disposition: form-data; name=\"${name}\"`;\n    if (fileName) {\n      contentInfo += `; filename=\"${fileName}\"`;\n    }\n    contentInfo += '\\nContent-Type: text/plain; charset=utf-8\\n';\n\n    this.multipart += `--${this.boundary}\\n${contentInfo}\\n${data}\\n--${this.boundary}--\\n`;\n  }\n}\n\ninterface QFnPayload {\n  infoString: string;\n  message: string;\n}\n\nconst DEFAULT_RATE_LIMIT = 420;\n\nexport default class DiscordTransport extends LoggerTransport {\n  static version = version;\n\n  readonly destination: string;\n  private readonly _axios?: AxiosInstance;\n  private readonly _fnQ?: FunctionQueue<QFnPayload, LoggerTransportResult>;\n  private readonly _rateLimit;\n\n  constructor(options: LoggerTransportOptions['options'] & {rateLimit?: number}) {\n    const r = Math.random().toString(36).substring(7);\n    super({...options, r});\n\n    this.destination = options.destination;\n\n    if (r !== this._r) {\n      return this;\n    }\n\n    this._rateLimit = options.rateLimit || DEFAULT_RATE_LIMIT;\n\n    this._axios = axios.create({\n      url: this.destination,\n    });\n\n    const qFn: QueueableFunction<QFnPayload, LoggerTransportResult> = async (payload) => {\n      return this.postToWebhook(payload);\n    };\n\n    const fnQ = new FunctionQueue(qFn, {waitTimeBetweenRuns: this._rateLimit, maxRetries: 0});\n    this._fnQ = fnQ;\n  }\n\n  async debug([prefixes, ...message]: unknown[]) {\n    const fnQ = this._fnQ as FunctionQueue<QFnPayload, LoggerTransportResult>;\n\n    const payloadId = fnQ.queuePayload(\n      {\n        infoString: `**${prefixes} DEBUG** \uD83D\uDC1E\uFE0F:`,\n        message: `${this.format(message)}`\n      }\n    );\n\n    fnQ.processQueue();\n    const {result, error} = await fnQ.getResult(payloadId);\n\n    if (error) {\n      throw error;\n    }\n\n    return result as LoggerTransportResult;\n  }\n\n  async info([prefixes, ...message]: unknown[]) {\n    const fnQ = this._fnQ as FunctionQueue<QFnPayload, LoggerTransportResult>;\n\n    const payloadId = fnQ.queuePayload(\n      {\n        infoString: `**${prefixes} INFO** \u2705\uFE0F\uFE0F:`,\n        message: `${this.format(message)}`\n      }\n    );\n\n    fnQ.processQueue();\n    const {result, error} = await fnQ.getResult(payloadId);\n\n    if (error) {\n      throw error;\n    }\n\n    return result as LoggerTransportResult;\n  }\n\n  async warn([prefixes, ...message]: unknown[]) {\n    const fnQ = this._fnQ as FunctionQueue<QFnPayload, LoggerTransportResult>;\n\n    const payloadId = fnQ.queuePayload(\n      {\n        infoString: `**${prefixes} WARN** \uD83D\uDFE1:`,\n        message: `${this.format(message)}`\n      }\n    );\n\n    fnQ.processQueue();\n    const {result, error} = await fnQ.getResult(payloadId);\n\n    if (error) {\n      throw error;\n    }\n\n    return result as LoggerTransportResult;\n  }\n\n  async error([prefixes, ...message]: unknown[]) {\n    const fnQ = this._fnQ as FunctionQueue<QFnPayload, LoggerTransportResult>;\n\n    const payloadId = fnQ.queuePayload(\n      {\n        infoString: `**${prefixes} ERROR** \uD83D\uDEA8\uFE0F:`,\n        message: `${this.format(message)}`\n      }\n    );\n\n    fnQ.processQueue();\n    const {result, error} = await fnQ.getResult(payloadId);\n\n    if (error) {\n      throw error;\n    }\n\n    return result as LoggerTransportResult;\n  }\n\n  async fatal([prefixes, ...message]: unknown[]) {\n    const fnQ = this._fnQ as FunctionQueue<QFnPayload, LoggerTransportResult>;\n\n    const payloadId = fnQ.queuePayload(\n      {\n        infoString: `**${prefixes} FATAL** \uD83D\uDC80:`,\n        message: `${this.format(message)}`\n      }\n    );\n\n    fnQ.processQueue();\n    const {result, error} = await fnQ.getResult(payloadId);\n\n    if (error) {\n      throw error;\n    }\n\n    return result as LoggerTransportResult;\n  }\n\n  async all([prefixes, ...message]: unknown[]) {\n    const fnQ = this._fnQ as FunctionQueue<QFnPayload, LoggerTransportResult>;\n\n    const payloadId = fnQ.queuePayload(\n      {\n        infoString: `**${prefixes} ALL** \uD83D\uDCDD:`,\n        message: `${this.format(message)}`\n      }\n    );\n\n    fnQ.processQueue();\n    const {result, error} = await fnQ.getResult(payloadId);\n\n    if (error) {\n      throw error;\n    }\n\n    return result as LoggerTransportResult;\n  }\n\n  async raw([prefixes, ...message]: unknown[]) {\n    const fnQ = this._fnQ as FunctionQueue<QFnPayload, LoggerTransportResult>;\n\n    const payloadId = fnQ.queuePayload(\n      {\n        infoString: '',\n        message: this.format(message)\n      }\n    );\n\n    fnQ.processQueue();\n    const {result, error} = await fnQ.getResult(payloadId);\n\n    if (error) {\n      throw error;\n    }\n\n    return result as LoggerTransportResult;\n  }\n\n  private async postToWebhook({infoString, message}: QFnPayload): Promise<LoggerTransportResult> {\n    const attachMessage = Boolean((infoString.length + message.length) >= 2000);\n\n    let content = '';\n    \n    if (infoString.length > 0) {\n      content = (attachMessage) ? infoString : `${infoString}\\n\\`\\`\\`${message}\\`\\`\\``;\n    } else if (!attachMessage) {\n      content = message;\n    }\n\n    let data;\n    let config: AxiosRequestConfig = {};\n    let response;\n\n    if (content.length > 0) {\n      data = {\n        content,\n      };\n\n      response = await (this._axios as AxiosInstance).post<undefined>(\n        this.destination,\n        data,\n        config,\n      ).catch((reason) => {\n        return {\n          status: 400,\n          reason,\n        };\n      });\n\n      if (response.status < 200 || response.status > 399) {\n        throw new Error(`Bad Response: ${(response as any).reason}`);\n      };\n    }\n\n    if (attachMessage) {\n      const multi = new Multipart(\n        { name: 'file', data: message, fileName: 'message.txt' },\n      );\n\n      data = multi.multipart;\n\n      config = {\n        headers: {\n          \"Content-Type\": `multipart/form-data; boundary=${multi.boundary}`,\n        }\n      };\n\n      await sleep(this._rateLimit || DEFAULT_RATE_LIMIT);\n\n      response = await (this._axios as AxiosInstance).post<undefined>(\n        this.destination,\n        data,\n        config,\n      ).catch((reason) => {\n        return {\n          status: 400,\n          reason,\n        };\n      });\n\n      if (response.status < 200 || response.status > 399) {\n        throw new Error(`Bad Response: ${(response as any).reason}`);\n      };\n    }\n\n    return {\n      destination: this.destination,\n      channelName: this.channelName,\n      result: true,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
